# 🔗 PuzzleCraft AI - 프론트엔드-백엔드 통합 분석 및 구현 계획

## 📋 **개요**

이 문서는 PuzzleCraft AI 프로젝트의 프론트엔드 임시 구현 분석을 바탕으로 백엔드의 실제 구현 상태를 분석하고, 완전한 통합을 위한 상세한 구현 계획을 제시합니다.

## 🔍 **백엔드 구현 상태 분석**

### **✅ 완전히 구현된 기능**

#### **1. 인증 시스템 (Auth Service)**
- **위치**: `backend/auth-service/main.py`
- **구현 상태**: ✅ **완료**
- **기능**:
  - JWT 토큰 기반 인증
  - 사용자 회원가입/로그인/로그아웃
  - 비밀번호 해싱 (bcrypt)
  - SQLAlchemy 기반 사용자 모델
  - 토큰 검증 및 사용자 정보 조회

#### **2. API Gateway 라우터**
- **위치**: `backend/api-gateway/routers/`
- **구현 상태**: ✅ **완료**

**인증 라우터** (`auth.py`):
- `POST /api/v1/auth/login` - 로그인
- `POST /api/v1/auth/register` - 회원가입
- `GET /api/v1/auth/me` - 현재 사용자 정보
- `POST /api/v1/auth/logout` - 로그아웃

**퍼즐 라우터** (`puzzles.py`):
- `POST /api/v1/puzzles/analyze-complexity` - 복잡도 분석
- `POST /api/v1/puzzles/generate-difficulty-profile` - 난이도 프로필
- `POST /api/v1/puzzles/generate-intelligent` - 지능형 퍼즐 생성
- `GET /api/v1/puzzles/status/{task_id}` - 퍼즐 상태 조회
- `GET /api/v1/puzzles/result/{task_id}` - 퍼즐 결과 조회
- `POST /api/v1/puzzles/preview` - 퍼즐 미리보기 ✅
- `POST /api/v1/puzzles/generate` - 퍼즐 생성
- `GET /api/v1/puzzles/{puzzle_id}` - 퍼즐 조회
- `GET /api/v1/puzzles` - 퍼즐 목록
- `DELETE /api/v1/puzzles/{puzzle_id}` - 퍼즐 삭제

**게임 라우터** (`games.py`):
- `POST /api/v1/games/sessions` - 게임 세션 생성
- `GET /api/v1/games/sessions/{session_id}` - 게임 세션 조회
- `POST /api/v1/games/sessions/{session_id}/moves` - 게임 이동
- `POST /api/v1/games/sessions/{session_id}/complete` - 게임 완료
- `GET /api/v1/games/leaderboard` - 리더보드
- `GET /api/v1/games/sessions` - 게임 세션 목록

### **⚠️ 부분적으로 구현된 기능**

#### **1. 사용자 관리 (Users Router)**
- **위치**: `backend/api-gateway/routers/users.py`
- **구현 상태**: 🟡 **부분 구현** (구조만 있고 실제 로직 TODO)

**구현된 엔드포인트 구조**:
- `GET /api/v1/users/profile` - 사용자 프로필 (TODO)
- `PUT /api/v1/users/profile` - 프로필 업데이트 (TODO)
- `GET /api/v1/users/stats` - 사용자 통계 (TODO) ⚠️ **프론트엔드 필수**
- `GET /api/v1/users/achievements` - 업적 (TODO)
- `GET /api/v1/users/history` - 게임 히스토리 (TODO)
- `DELETE /api/v1/users/account` - 계정 삭제 (TODO)

### **🔴 누락된 기능**

#### **1. 스타일 전송 API**
- **프론트엔드 요구사항**: 스타일 미리보기 및 적용
- **현재 상태**: 스타일 전송 서비스는 있지만 API Gateway에 라우터 없음
- **필요한 엔드포인트**:
  - `POST /api/v1/style/preview` - 스타일 미리보기
  - `POST /api/v1/style/apply` - 스타일 적용

#### **2. 토큰 갱신 API**
- **프론트엔드 요구사항**: JWT 토큰 자동 갱신
- **현재 상태**: 누락
- **필요한 엔드포인트**:
  - `POST /api/v1/auth/refresh` - 토큰 갱신

## 🎯 **프론트엔드 구현 상태 분석**

### **✅ 구현된 기능**
- **UI 컴포넌트**: 모든 페이지 및 컴포넌트 구조 완성
- **라우팅**: React Router 기반 페이지 라우팅
- **AI 서비스 클라이언트**: `aiServiceClient.ts` 구현

### **🔴 누락된 기능**
- **인증 관련**:
  - AuthContext 및 AuthProvider
  - JWT 토큰 관리 유틸리티
  - 인증 API 클라이언트
  - 인증 상태 기반 라우팅

- **데이터 연동**:
  - 사용자 통계 API 연동
  - 실제 퍼즐 데이터 로딩
  - 에러 처리 및 로딩 상태 관리

## 🛠️ **통합 구현 계획**

### **Phase 1: 백엔드 API 완성 (1주)**

#### **1.1 사용자 통계 API 구현**
**파일**: `backend/api-gateway/routers/users.py`

```python
@router.get("/stats", response_model=UserStats)
async def get_user_stats(credentials: HTTPAuthorizationCredentials = Depends(security)):
    async with httpx.AsyncClient() as client:
        try:
            # 게임 매니저 서비스에서 사용자 통계 조회
            response = await client.get(
                f"{GAME_MANAGER_URL}/users/{user_id}/stats",
                headers={"Authorization": f"Bearer {credentials.credentials}"},
                timeout=10.0
            )
            
            if response.status_code == 200:
                return response.json()
            else:
                raise HTTPException(
                    status_code=response.status_code,
                    detail="Failed to fetch user stats"
                )
        except httpx.RequestError:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Game manager service unavailable"
            )
```

#### **1.2 스타일 전송 라우터 추가**
**파일**: `backend/api-gateway/routers/style.py` (신규 생성)

```python
from fastapi import APIRouter, UploadFile, File, HTTPException
import httpx
import os

router = APIRouter()
STYLE_TRANSFER_URL = os.getenv("STYLE_TRANSFER_URL", "http://style-transfer:8005")

@router.post("/preview")
async def generate_style_preview(
    file: UploadFile = File(...),
    style_type: str = "classic"
):
    async with httpx.AsyncClient() as client:
        files = {"file": (file.filename, file.file, file.content_type)}
        data = {"style_type": style_type, "preview_only": True}
        
        response = await client.post(
            f"{STYLE_TRANSFER_URL}/apply-style",
            files=files,
            data=data,
            timeout=30.0
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise HTTPException(
                status_code=response.status_code,
                detail="Style preview generation failed"
            )

@router.post("/apply")
async def apply_style(
    file: UploadFile = File(...),
    style_type: str = "classic"
):
    async with httpx.AsyncClient() as client:
        files = {"file": (file.filename, file.file, file.content_type)}
        data = {"style_type": style_type}
        
        response = await client.post(
            f"{STYLE_TRANSFER_URL}/apply-style",
            files=files,
            data=data,
            timeout=60.0
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            raise HTTPException(
                status_code=response.status_code,
                detail="Style application failed"
            )
```

#### **1.3 토큰 갱신 API 추가**
**파일**: `backend/api-gateway/routers/auth.py`

```python
@router.post("/refresh", response_model=Token)
async def refresh_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(
                f"{AUTH_SERVICE_URL}/refresh",
                headers={"Authorization": f"Bearer {credentials.credentials}"},
                timeout=10.0
            )
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 401:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Token refresh failed"
                )
            else:
                raise HTTPException(
                    status_code=response.status_code,
                    detail="Authentication service error"
                )
        except httpx.RequestError:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Authentication service unavailable"
            )
```

### **Phase 2: 프론트엔드 인증 시스템 구현 (1주)**

#### **2.1 인증 컨텍스트 구현**
**파일**: `frontend/web/src/contexts/AuthContext.tsx` (신규 생성)

```typescript
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react'

interface User {
  id: number
  username: string
  email: string
  is_active: boolean
}

interface AuthContextType {
  user: User | null
  isAuthenticated: boolean
  login: (username: string, password: string) => Promise<void>
  register: (username: string, email: string, password: string) => Promise<void>
  logout: () => void
  loading: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  const isAuthenticated = !!user

  useEffect(() => {
    const token = localStorage.getItem('auth_token')
    if (token) {
      fetchCurrentUser(token)
    } else {
      setLoading(false)
    }
  }, [])

  const fetchCurrentUser = async (token: string) => {
    try {
      const response = await fetch(`${import.meta.env.VITE_API_URL}/api/v1/auth/me`, {
        headers: { Authorization: `Bearer ${token}` }
      })
      
      if (response.ok) {
        const userData = await response.json()
        setUser(userData)
      } else {
        localStorage.removeItem('auth_token')
      }
    } catch (error) {
      console.error('Failed to fetch current user:', error)
      localStorage.removeItem('auth_token')
    } finally {
      setLoading(false)
    }
  }

  const login = async (username: string, password: string) => {
    const response = await fetch(`${import.meta.env.VITE_API_URL}/api/v1/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.detail || 'Login failed')
    }

    const { access_token } = await response.json()
    localStorage.setItem('auth_token', access_token)
    await fetchCurrentUser(access_token)
  }

  const register = async (username: string, email: string, password: string) => {
    const response = await fetch(`${import.meta.env.VITE_API_URL}/api/v1/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, email, password })
    })

    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.detail || 'Registration failed')
    }

    const { access_token } = await response.json()
    localStorage.setItem('auth_token', access_token)
    await fetchCurrentUser(access_token)
  }

  const logout = () => {
    localStorage.removeItem('auth_token')
    setUser(null)
  }

  const value = {
    user,
    isAuthenticated,
    login,
    register,
    logout,
    loading
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}
```

#### **2.2 API 클라이언트 구현**
**파일**: `frontend/web/src/services/authClient.ts` (신규 생성)

```typescript
const API_BASE_URL = import.meta.env.VITE_API_URL

export class AuthClient {
  private getAuthHeaders() {
    const token = localStorage.getItem('auth_token')
    return token ? { Authorization: `Bearer ${token}` } : {}
  }

  async login(username: string, password: string) {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password })
    })

    if (!response.ok) {
      throw new Error('Login failed')
    }

    return response.json()
  }

  async register(username: string, email: string, password: string) {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, email, password })
    })

    if (!response.ok) {
      throw new Error('Registration failed')
    }

    return response.json()
  }

  async getCurrentUser() {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/me`, {
      headers: this.getAuthHeaders()
    })

    if (!response.ok) {
      throw new Error('Failed to get current user')
    }

    return response.json()
  }

  async logout() {
    const response = await fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
      method: 'POST',
      headers: this.getAuthHeaders()
    })

    if (!response.ok) {
      throw new Error('Logout failed')
    }

    return response.json()
  }
}

export const authClient = new AuthClient()
```

### **Phase 3: 데이터 연동 구현 (1주)**

#### **3.1 사용자 통계 훅 구현**
**파일**: `frontend/web/src/hooks/useUserStats.ts` (신규 생성)

```typescript
import { useState, useEffect } from 'react'

interface UserStats {
  total_puzzles_completed: number
  total_play_time: number
  average_completion_time: number
  best_score: number
  current_streak: number
}

export const useUserStats = () => {
  const [stats, setStats] = useState<UserStats | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchStats = async () => {
      try {
        const token = localStorage.getItem('auth_token')
        if (!token) {
          throw new Error('No authentication token')
        }

        const response = await fetch(`${import.meta.env.VITE_API_URL}/api/v1/users/stats`, {
          headers: { Authorization: `Bearer ${token}` }
        })

        if (!response.ok) {
          throw new Error('Failed to fetch user stats')
        }

        const statsData = await response.json()
        setStats(statsData)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error')
      } finally {
        setLoading(false)
      }
    }

    fetchStats()
  }, [])

  return { stats, loading, error }
}
```

#### **3.2 스타일 API 클라이언트 구현**
**파일**: `frontend/web/src/services/styleClient.ts` (신규 생성)

```typescript
const API_BASE_URL = import.meta.env.VITE_API_URL

export class StyleClient {
  async generatePreview(file: File, styleType: string) {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('style_type', styleType)

    const response = await fetch(`${API_BASE_URL}/api/v1/style/preview`, {
      method: 'POST',
      body: formData
    })

    if (!response.ok) {
      throw new Error('Style preview generation failed')
    }

    return response.json()
  }

  async applyStyle(file: File, styleType: string) {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('style_type', styleType)

    const response = await fetch(`${API_BASE_URL}/api/v1/style/apply`, {
      method: 'POST',
      body: formData
    })

    if (!response.ok) {
      throw new Error('Style application failed')
    }

    return response.json()
  }
}

export const styleClient = new StyleClient()
```

### **Phase 4: 컴포넌트 업데이트 (1주)**

#### **4.1 로그인 컴포넌트 업데이트**
**파일**: `frontend/web/src/pages/Login.tsx`

```typescript
// 기존 TODO 주석 제거하고 실제 로직으로 교체
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  setLoading(true)
  setError('')

  try {
    await login(formData.username, formData.password)
    navigate('/dashboard')
  } catch (err) {
    setError(err instanceof Error ? err.message : 'Login failed')
  } finally {
    setLoading(false)
  }
}
```

#### **4.2 대시보드 컴포넌트 업데이트**
**파일**: `frontend/web/src/pages/Dashboard.tsx`

```typescript
// 하드코딩된 데이터를 실제 API 호출로 교체
const { stats, loading: statsLoading } = useUserStats()
const { puzzles, loading: puzzlesLoading } = useRecentPuzzles()

// 로딩 상태 및 에러 처리 추가
if (statsLoading || puzzlesLoading) {
  return <LoadingSpinner />
}
```

## 📋 **구현 체크리스트**

### **백엔드 (1주)**
- [ ] 사용자 통계 API 실제 로직 구현
- [ ] 스타일 전송 라우터 추가
- [ ] 토큰 갱신 API 구현
- [ ] API Gateway에 스타일 라우터 등록

### **프론트엔드 (3주)**
- [ ] AuthContext 및 AuthProvider 구현
- [ ] 인증 API 클라이언트 구현
- [ ] 사용자 통계 훅 구현
- [ ] 스타일 API 클라이언트 구현
- [ ] 로그인/회원가입 컴포넌트 업데이트
- [ ] 대시보드 실제 데이터 연동
- [ ] 퍼즐 생성 스타일 기능 연동
- [ ] 에러 처리 및 로딩 상태 개선

### **통합 테스트 (1주)**
- [ ] 인증 플로우 테스트
- [ ] 퍼즐 생성 플로우 테스트
- [ ] 스타일 적용 플로우 테스트
- [ ] 에러 시나리오 테스트

## 🎯 **결론**

### **현재 상태 요약**
- **백엔드**: 핵심 기능 80% 구현 완료, 일부 API 로직 구현 필요
- **프론트엔드**: UI 구조 100% 완성, API 연동 20% 완료
- **통합**: 기본 인프라 준비 완료, 실제 연동 작업 필요

### **예상 완료 시간**
- **총 소요 시간**: 4-5주
- **우선순위**: 인증 시스템 → 데이터 연동 → 스타일 기능 → 최적화

### **성공 기준**
1. 모든 TODO 주석 제거
2. 실제 백엔드 API와 완전 연동
3. 에러 처리 및 사용자 피드백 완성
4. 성능 최적화 및 사용자 경험 향상

이 계획을 통해 PuzzleCraft AI는 완전히 동작하는 풀스택 애플리케이션으로 완성될 것입니다.